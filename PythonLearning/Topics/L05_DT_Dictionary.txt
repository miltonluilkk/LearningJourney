Datatype : Dictionary 

Python dictionary : 

# unordered collection of items which each item is stored as a key-value pair
# mutable - change their content without changing their identity
# dynamic, allowing you to add or remove items.

*** Key: A unique identifier for a value. Keys must be immutable (e.g., strings, numbers, tuples). ( you cant put a list here ) 
Value: The data associated with the key. Values can be of any type (e.g., integers, strings, lists, other dictionaries). 
(basically anything) 

Syntax 
1. Keys and values are separated by a colon :
2. Key-value pairs are separated by commas ,
3. The entire dictionary is enclosed in curly braces {}

my_dict = {
    "key1": "value1",
    "key2": "value2",
    "key3": "value3"
}

Creations 

Empty Dictionary 
###  my_dict = {}

Dictionary with Initial Values 
### my_dict = {"name": "Alice", "age": 25, "city": "New York"}


### not recommended 
Using dict() Constructor:
my_dict = dict(name="Alice", age=25, city="New York")

Accessing values 
Use the key to access the corresponding value:
###print(my_dict["name"])  # Output: Alice

If the key doesn't exist, it raises a KeyError. To avoid this, use the get() method:
##print(my_dict.get("name"))  # Output: Alice
###print(my_dict.get("gender", "Unknown"))  # Output: Unknown (default value)

Adding new pair  / modifying pairs
Add a new key-value pair:
#my_dict["gender"] = "Female"

Update an existing key:
#my_dict["age"] = 26

Use the update() method to merge another dictionary:
my_dict.update({"age": 26, "job": "Engineer"})

Removing 
Use del to remove a key-value pair:
#del my_dict["city"]

Use pop() to remove a key and return its value:
#age = my_dict.pop("age")

Use popitem() to remove and return the last inserted key-value pair:
# key, value = my_dict.popitem()

Use clear() to remove all items:
#my_dict.clear()

keys(): Returns a view of all keys.
#print(my_dict.keys())  # Output: dict_keys(['name', 'age', 'city'])

values(): Returns a view of all values.
#print(my_dict.values())  # Output: dict_values(['Alice', 25, 'New York'])

items(): Returns a view of all key-value pairs as tuples.
#print(my_dict.items())  # Output: dict_items([('name', 'Alice'), ('age', 25), ('city', 'New York')])

copy(): Returns a shallow copy of the dictionary.
#new_dict = my_dict.copy()

nested diict 
#dictionary inside a dictionary 
nested_dict = {
    "person1": {"name": "Alice", "age": 25},
    "person2": {"name": "Bob", "age": 30}
}
print(nested_dict["person1"]["name"])  # Output: Alice

Iterating
Iterate over keys:
for key in my_dict:
    print(key, my_dict[key])
	
Iterate over key-value pairs:
for key, value in my_dict.items():
    print(key, value)
	
Checking for Key Existence
if "name" in my_dict:
    print("Name exists")
	
Dictionary Views
#keys(), values(), and items() return view objects that reflect changes in the dictionary:
#keys_view = my_dict.keys()
my_dict["gender"] = "Female"
print(keys_view)  # Output: dict_keys(['name', 'age', 'city', 'gender'])

In Python 3.7+, dictionaries maintain insertion order. In earlier versions, dictionaries were unordered.
////////////	
Practice probelms::
What is the difference between a dictionary and a list?
#Dictionary: Stores key-value pairs. Keys are unique and immutable. Access is via keys.
#List: Stores ordered elements. Access is via indices (positions).

Can a dictionary have duplicate keys?
#No, keys must be unique. If you assign a value to an existing key, it will overwrite the previous value.

What happens if you try to access a key that doesn't exist?
#It raises a KeyError. Use the get() method to avoid this:
# value = my_dict.get("nonexistent_key", "default_value")

Can a dictionary key be a list or another dictionary?
No, keys must be immutable. 
Lists and dictionaries are mutable, so they cannot be used as keys. Tuples can be used as keys if they contain only immutable elements.
	
How do you merge two dictionaries?
#.update()
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
dict1.update(dict2)
	
In Python 3.9+, you can use the | operator:
merged_dict = dict1 | dict2

What is the difference between pop() and popitem()?
pop(): Removes a specific key and returns its value.
##value = my_dict.pop("key")
popitem(): Removes and returns the last inserted key-value pair.
##key, value = my_dict.popitem()

How do you create a dictionary from two lists (keys and values)?
##Use the zip() function:
keys = ["a", "b", "c"]
values = [1, 2, 3]
my_dict = dict(zip(keys, values))

What is a dictionary comprehension?
squares = {x: x**2 for x in range(1, 6)}

How do you check if a value exists in a dictionary?
#Use the in keyword with the values() method:
if "Alice" in my_dict.values():
    print("Value exists")

What is the time complexity of dictionary operations?
Access, insertion, and deletion operations are O(1) on average due to hashing.


Shallow copy -> just referencing 
#changes to those elements will be reflected in both the original and the shallow copy.

Is Dictionary the Fastest?
##Yes, dictionaries are one of the fastest data structures in Python for certain operations, particularly lookup, insertion, and deletion.
This is because dictionaries are implemented using hash tables, which provide average-case O(1) time complexity for these operations.

Why Are Dictionaries Fast?
#Hashing: Keys are hashed to compute an index where the corresponding value is stored. This allows for fast access.
#Collision Handling: Python uses techniques like open addressing to handle hash collisions efficiently.
#Optimized Implementation: Dictionaries are highly optimized in Python's core implementation (CPython).

Comparison with Other Data Structures:
Operation	Dictionary	List	Set
Lookup (by key)	O(1)	O(n)	O(1)
Insertion	O(1)	O(n)	O(1)
Deletion	O(1)	O(n)	O(1)
Iteration	O(n)	O(n)	O(n)


When to Use Dictionaries:
#When you need fast lookups, insertions, or deletions based on keys.
#When you need to store key-value pairs.
#When the order of elements is not important (or you're using Python 3.7+, where dictionaries maintain insertion order).

Hard Cross-Table Questions with Joins, Calculations, and Window Functions
1. Find Employees Who Earn More Than Their Managers (Self-Join)
Tables:

employees: id, name, salary, manager_id

Question: Write a query to find employees who earn more than their managers.

Answer:

sql
复制
SELECT e.name AS employee_name, e.salary AS employee_salary, m.name AS manager_name, m.salary AS manager_salary
FROM employees e
INNER JOIN employees m ON e.manager_id = m.id
WHERE e.salary > m.salary;
2. Find Departments with the Highest Average Salary (Aggregation + Window Function)
Tables:

employees: id, name, salary, department_id

departments: id, name

Question: Write a query to find the department(s) with the highest average salary.

Answer:

sql
复制
WITH department_avg_salary AS (
    SELECT d.name AS department_name, AVG(e.salary) AS avg_salary
    FROM employees e
    INNER JOIN departments d ON e.department_id = d.id
    GROUP BY d.name
)
SELECT department_name, avg_salary
FROM department_avg_salary
WHERE avg_salary = (SELECT MAX(avg_salary) FROM department_avg_salary);
3. Find Customers Who Placed Orders in All Categories (Cross-Table + Subquery)
Tables:

customers: id, name

orders: id, customer_id, category_id

categories: id, name

Question: Write a query to find customers who have placed orders in all available categories.

Answer:

sql
复制
SELECT c.name AS customer_name
FROM customers c
WHERE NOT EXISTS (
    SELECT cat.id
    FROM categories cat
    WHERE NOT EXISTS (
        SELECT 1
        FROM orders o
        WHERE o.customer_id = c.id AND o.category_id = cat.id
    )
);
4. Find Employees Who Have Never Been Managers (Self-Join + Subquery)
Tables:

employees: id, name, manager_id

Question: Write a query to find employees who have never been managers.

Answer:

sql
复制
SELECT e.name AS employee_name
FROM employees e
LEFT JOIN employees m ON e.id = m.manager_id
WHERE m.manager_id IS NULL;
5. Find the Top 3 Customers by Total Spending (Aggregation + Window Function)
Tables:

customers: id, name

orders: id, customer_id, amount

Question: Write a query to find the top 3 customers by total spending.

Answer:

sql
复制
WITH customer_spending AS (
    SELECT c.name AS customer_name, SUM(o.amount) AS total_spent
    FROM customers c
    INNER JOIN orders o ON c.id = o.customer_id
    GROUP BY c.name
)
SELECT customer_name, total_spent
FROM customer_spending
ORDER BY total_spent DESC
LIMIT 3;
6. Find Products That Have Never Been Ordered (LEFT JOIN + NULL Check)
Tables:

products: id, name

orders: id, product_id

Question: Write a query to find products that have never been ordered.

Answer:

sql
复制
SELECT p.name AS product_name
FROM products p
LEFT JOIN orders o ON p.id = o.product_id
WHERE o.product_id IS NULL;
7. Find Employees Who Work in the Same Department as Their Manager (Self-Join + INNER JOIN)
Tables:

employees: id, name, department_id, manager_id

departments: id, name

Question: Write a query to find employees who work in the same department as their manager.

Answer:

sql
复制
SELECT e.name AS employee_name, d.name AS department_name
FROM employees e
INNER JOIN employees m ON e.manager_id = m.id
INNER JOIN departments d ON e.department_id = d.id
WHERE e.department_id = m.department_id;
8. Find Customers Who Have Placed Orders in Consecutive Months (Window Function + Self-Join)
Tables:

customers: id, name

orders: id, customer_id, order_date

Question: Write a query to find customers who have placed orders in at least two consecutive months.

Answer:

sql
复制
WITH customer_order_months AS (
    SELECT customer_id, DATE_FORMAT(order_date, '%Y-%m') AS order_month
    FROM orders
    GROUP BY customer_id, DATE_FORMAT(order_date, '%Y-%m')
)
SELECT DISTINCT c.name AS customer_name
FROM customers c
INNER JOIN customer_order_months com1 ON c.id = com1.customer_id
INNER JOIN customer_order_months com2 ON c.id = com2.customer_id
WHERE com2.order_month = DATE_ADD(com1.order_month, INTERVAL 1 MONTH);
9. Calculate the Difference Between Each Employee's Salary and the Department Average (Window Function)
Tables:

employees: id, name, salary, department_id

Question: Write a query to calculate the difference between each employee's salary and the average salary of their department.

Answer:

sql
复制
SELECT name, salary, department_id,
       salary - AVG(salary) OVER (PARTITION BY department_id) AS salary_difference_from_avg
FROM employees;
10. Find the Cumulative Sum of Sales by Quarter (Window Function)
Tables:

sales: id, sale_date, amount

Question: Write a query to calculate the cumulative sum of sales by quarter.

Answer:

sql
复制
SELECT sale_date, amount,
       SUM(amount) OVER (PARTITION BY YEAR(sale_date), QUARTER(sale_date) ORDER BY sale_date) AS cumulative_sum
FROM sales;
11. Find the Employees with the Top 2 Salaries in Each Department (Window Function)
Tables:

employees: id, name, salary, department_id

Question: Write a query to find the employees with the top 2 salaries in each department.

Answer:

sql
复制
WITH ranked_employees AS (
    SELECT name, salary, department_id,
           RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
    FROM employees
)
SELECT name, salary, department_id
FROM ranked_employees
WHERE salary_rank <= 2;
12. Calculate the Median Salary for Each Department (Window Function + Subquery)
Tables:

employees: id, name, salary, department_id

Question: Write a query to calculate the median salary for each department.

Answer:

sql
复制
WITH ranked_salaries AS (
    SELECT salary, department_id,
           ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary) AS row_num,
           COUNT(*) OVER (PARTITION BY department_id) AS total_count
    FROM employees
)
SELECT department_id, AVG(salary) AS median_salary
FROM ranked_salaries
WHERE row_num IN (FLOOR((total_count + 1) / 2), CEIL((total_count + 1) / 2))
GROUP BY department_id;

Financial SQL Questions for Hedge Funds
1. Calculate the Daily Profit and Loss (PnL) for Each Portfolio
Tables:

trades: trade_id, portfolio_id, trade_date, quantity, price

portfolios: portfolio_id, portfolio_name

Question: Write a query to calculate the daily PnL for each portfolio. Assume PnL is calculated as the sum of (quantity * price) for all trades on a given day.

Answer:

sql
复制
SELECT p.portfolio_name, t.trade_date,
       SUM(t.quantity * t.price) AS daily_pnl
FROM trades t
INNER JOIN portfolios p ON t.portfolio_id = p.portfolio_id
GROUP BY p.portfolio_name, t.trade_date
ORDER BY t.trade_date;
2. Calculate the Cumulative PnL for Each Portfolio Over Time
Tables:

trades: trade_id, portfolio_id, trade_date, quantity, price

portfolios: portfolio_id, portfolio_name

Question: Write a query to calculate the cumulative PnL for each portfolio over time.

Answer:

sql
复制
SELECT p.portfolio_name, t.trade_date,
       SUM(t.quantity * t.price) OVER (PARTITION BY p.portfolio_name ORDER BY t.trade_date) AS cumulative_pnl
FROM trades t
INNER JOIN portfolios p ON t.portfolio_id = p.portfolio_id
ORDER BY p.portfolio_name, t.trade_date;
3. Find the Top 3 Performing Portfolios by Total PnL
Tables:

trades: trade_id, portfolio_id, quantity, price

portfolios: portfolio_id, portfolio_name

Question: Write a query to find the top 3 performing portfolios by total PnL.

Answer:

sql
复制
WITH portfolio_pnl AS (
    SELECT p.portfolio_name, SUM(t.quantity * t.price) AS total_pnl
    FROM trades t
    INNER JOIN portfolios p ON t.portfolio_id = p.portfolio_id
    GROUP BY p.portfolio_name
)
SELECT portfolio_name, total_pnl
FROM portfolio_pnl
ORDER BY total_pnl DESC
LIMIT 3;
4. Calculate the Moving Average of Trade Prices for Each Stock
Tables:

trades: trade_id, stock_id, trade_date, price

stocks: stock_id, stock_name

Question: Write a query to calculate the 7-day moving average of trade prices for each stock.

Answer:

sql
复制
SELECT s.stock_name, t.trade_date, t.price,
       AVG(t.price) OVER (PARTITION BY s.stock_name ORDER BY t.trade_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_price
FROM trades t
INNER JOIN stocks s ON t.stock_id = s.stock_id
ORDER BY s.stock_name, t.trade_date;
5. Find Stocks with the Highest Daily Trading Volume
Tables:

trades: trade_id, stock_id, trade_date, quantity

stocks: stock_id, stock_name

Question: Write a query to find the stocks with the highest daily trading volume.

Answer:

sql
复制
WITH daily_volume AS (
    SELECT s.stock_name, t.trade_date, SUM(t.quantity) AS total_volume
    FROM trades t
    INNER JOIN stocks s ON t.stock_id = s.stock_id
    GROUP BY s.stock_name, t.trade_date
)
SELECT stock_name, trade_date, total_volume
FROM daily_volume
ORDER BY total_volume DESC
LIMIT 10;
6. Calculate the Sharpe Ratio for Each Portfolio
Tables:

trades: trade_id, portfolio_id, trade_date, quantity, price

portfolios: portfolio_id, portfolio_name

Question: Write a query to calculate the Sharpe Ratio for each portfolio. Assume the risk-free rate is 0.01 and Sharpe Ratio = (Average Daily Return - Risk-Free Rate) / Standard Deviation of Daily Returns.

Answer:

sql
复制
WITH daily_returns AS (
    SELECT p.portfolio_name, t.trade_date,
           (SUM(t.quantity * t.price) - LAG(SUM(t.quantity * t.price), 1) OVER (PARTITION BY p.portfolio_name ORDER BY t.trade_date)) / LAG(SUM(t.quantity * t.price), 1) OVER (PARTITION BY p.portfolio_name ORDER BY t.trade_date)) AS daily_return
    FROM trades t
    INNER JOIN portfolios p ON t.portfolio_id = p.portfolio_id
    GROUP BY p.portfolio_name, t.trade_date
),
sharpe_ratio AS (
    SELECT portfolio_name,
           (AVG(daily_return) - 0.01) / STDDEV(daily_return)) AS sharpe_ratio
    FROM daily_returns
    GROUP BY portfolio_name
)
SELECT portfolio_name, sharpe_ratio
FROM sharpe_ratio;
7. Find the Maximum Drawdown for Each Portfolio
Tables:

trades: trade_id, portfolio_id, trade_date, quantity, price

portfolios: portfolio_id, portfolio_name

Question: Write a query to calculate the maximum drawdown for each portfolio. Drawdown is the peak-to-trough decline during a specific period.

Answer:

sql
复制
WITH portfolio_values AS (
    SELECT p.portfolio_name, t.trade_date,
           SUM(t.quantity * t.price) AS portfolio_value
    FROM trades t
    INNER JOIN portfolios p ON t.portfolio_id = p.portfolio_id
    GROUP BY p.portfolio_name, t.trade_date
),
drawdowns AS (
    SELECT portfolio_name, trade_date, portfolio_value,
           (portfolio_value - MAX(portfolio_value) OVER (PARTITION BY portfolio_name ORDER BY trade_date)) / MAX(portfolio_value) OVER (PARTITION BY portfolio_name ORDER BY trade_date)) AS drawdown
    FROM portfolio_values
)
SELECT portfolio_name, MIN(drawdown) AS max_drawdown
FROM drawdowns
GROUP BY portfolio_name;
8. Calculate the Correlation Between Two Stocks' Daily Returns
Tables:

trades: trade_id, stock_id, trade_date, quantity, price

stocks: stock_id, stock_name

Question: Write a query to calculate the correlation between the daily returns of two stocks (e.g., Stock A and Stock B).

Answer:

sql
复制
WITH stock_returns AS (
    SELECT stock_id, trade_date,
           (SUM(quantity * price) - LAG(SUM(quantity * price), 1) OVER (PARTITION BY stock_id ORDER BY trade_date)) / LAG(SUM(quantity * price), 1) OVER (PARTITION BY stock_id ORDER BY trade_date)) AS daily_return
    FROM trades
    GROUP BY stock_id, trade_date
)
SELECT CORR(a.daily_return, b.daily_return) AS correlation
FROM stock_returns a
INNER JOIN stock_returns b ON a.trade_date = b.trade_date
WHERE a.stock_id = 'Stock_A' AND b.stock_id = 'Stock_B';
9. Calculate the Value-at-Risk (VaR) for a Portfolio
Tables:

trades: trade_id, portfolio_id, trade_date, quantity, price

portfolios: portfolio_id, portfolio_name

Question: Write a query to calculate the 95% Value-at-Risk (VaR) for a portfolio. Assume VaR is the 5th percentile of daily returns.

Answer:

sql
复制
WITH daily_returns AS (
    SELECT p.portfolio_name, t.trade_date,
           (SUM(t.quantity * t.price) - LAG(SUM(t.quantity * t.price), 1) OVER (PARTITION BY p.portfolio_name ORDER BY t.trade_date)) / LAG(SUM(t.quantity * t.price), 1) OVER (PARTITION BY p.portfolio_name ORDER BY t.trade_date)) AS daily_return
    FROM trades t
    INNER JOIN portfolios p ON t.portfolio_id = p.portfolio_id
    GROUP BY p.portfolio_name, t.trade_date
)
SELECT portfolio_name, PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY daily_return) AS var_95
FROM daily_returns
GROUP BY portfolio_name;



