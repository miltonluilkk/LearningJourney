What did I learn from each leetcode 

1. Contains Duplicate

This is an easy question that to think about
so thinking of 2 scenarios 
[1,2,3,3]  # Output : True
[1,2,3,4]  # Output : False

The first thought coming out would be forloop each of the numbers twice so it would be accomplished.. how to do this ?? it will be good to remember

i --> it will for loop the whole set once
j --> it will for loop the i+1, so it's forever 1 step ahead of i --> when it's the last number , i,e for example it's [1,2,3,4] when it's i==3 -> num[3] , 
it will be range(3+1,4) so it will not compare.. so it's working

n = len(nums)
for i in range(n):
	for j in range(i+1, n):
		if nums[i] == nums[j]:
			return(True)
return(False) 

The second thought coming out would also be easy, that's also forloop and this is actually a sorting method to find it out
I think this is actually a good solution given for a support/automations as to resolve the problems
the learning thing is - if you want to loop the list once and compare the n vs n+1 number, we can loop 1,n, and compare n vs n-1 to avoid out of index issue 

n = len(nums)
for i in range(1, n):
	if nums[i] == nums[i-1]:
		return(True)
return(False)

Hash ways 
This is only when getting involved to leetcode, then we know about the hash ways

this is a veru clean solution, if the map contains the value then return true.
fast and clean solution 

hm = set()
for i in nums:
	if i in hm:
		return(True)
	else:
		hm.add(i)
return(False) 

bonus comparing the length of the list would be cleanest solution and seems only suitable for this solution
return( len(set(nums))  < len(nums) 

2. Valid Anagram
Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

Example 1:

Input: s = "racecar", t = "carrace"

Output: true

This question is the topic to let you to compute the map and compared 
first of the tricky solution is to sort and compare 

1. return(sorted(s) == sorted(t))  # this is tricky one and not applied to other situations

2. the general another idea is to generate the map of the characters 

for example , tac vs act 

there would be a map if you forloop both 

for i in s:
	hm_S[i] = hm.get(i, 0) + 1
for i in t:
	hm_T[i] = hm.get(i, 0) + 1
then comparing both the maps will be an answer

of course to combine it will be a cleaner soltuion

countS, countT = {}, {}
for i in range(len(s)) 
	countS[s[i]] = countS.get(s[i], 0 ) +1
	countT[t[i]] = countT.get(s[i], 0 ) +1

3. solution from leetcode. this is very clever to take the ASCII code in order to compute the question's answer

count = [0] * 26 ## because there would be 26 characters of english 
if len(s) != len(t):
	return(False) # this would be applicable to all situations, if length diff, it will be diff
for i in range(len(s)):
	count[ord(s[i]) - ord('a')] += 1
	count[ord(t[i]) - ord('a')] -= 1

for i in count:
	if i != 0:
		return(False)
return(True) 

# this is very clever solution , as if all = 0 it means they add and subtract later on




































